{
    "contents" : "library(jsonlite)\nlibrary(dplyr)\nlibrary(stringr)\n\n\n### load set data\n### fetched from https://mtgjson.com/\n\nload_setdata <- function(setname, local = TRUE){\n  if(local){\n    filepath <- paste0(\"setdata/\", setname, \".json\")\n  } else {\n    filepath <- paste0(\"https://mtgjson.com/json/\", setname, \".json\")\n  }\n  fromJSON(filepath)\n}\n\n### load card rating data\n### fetched from http://www.draftaholicsanonymous.com/\n\nload_cardratings <- function(setname){\n  filepath <- paste0(\"draftaholicsdata/\", setname, \".txt\")\n  rawdata <- read.table(filepath, sep = \"\\t\")[[1]] %>% as.character()\n  data_index <- seq(which(rawdata == \"Which Card Would You Choose?\") + 2, \n                    which(rawdata == \"Hover over a row to preview cards\") - 1)\n  dat <- rawdata[data_index]\n  df <- as.data.frame(t(matrix(dat, nrow = 3)), stringsAsFactors = FALSE)\n  names(df) <- c(\"rank\", \"name\", \"rating\")\n  df <- df %>% mutate(rank = as.numeric(rank),\n                      rating = as.numeric(rating))\n  list(\"timestamp\" = file.mtime(filepath),\n       \"carddata\" = df)\n}\n\n### join card ratings to card data\n\nattach_ratings <- function(setdata, ratingsdata){\n  mod_setdata <- setdata\n  mod_setdata$cards <- left_join(\n    mod_setdata$cards %>% \n      mutate(cleanname = lapply(str_extract_all(tolower(name), \"[a-z]+\"), \n                                FUN = function(x)paste0(x, collapse = \"\")) %>% unlist), \n    ratingsdata$carddata %>% \n      mutate(cleanname = lapply(str_extract_all(tolower(name), \"[a-z]+\"), \n                                FUN = function(x)paste0(x, collapse = \"\")) %>% unlist) %>% \n      select(-name),\n    by = \"cleanname\") %>% \n    select(-cleanname)\n  mod_setdata\n}\n\n### sample a given number of random boosters from setdata\n### allows seeding a fixed card through the argument fixcard\n\nsample_booster <- function(setdata, n_booster, fixcard = NULL){\n  content <- lapply(setdata$booster, function(x) first(x)) %>% unlist\n  \n  ## get set of rares, uncommons and commons\n  n_rares <- sum(content == \"rare\")\n  rares <- setdata$cards  %>%  \n    filter(!is.na(rating), rarity %in% c(\"Rare\", \"Mythic Rare\")) %>%\n    mutate(prob = ifelse(rarity == \"Mythic Rare\", 0.5, 1))\n  n_uncommons <- sum(content == \"uncommon\")\n  uncommons <- setdata$cards  %>%  \n    filter(!is.na(rating), rarity %in% c(\"Uncommon\")) \n  n_commons <- sum(content == \"common\")\n  commons <- setdata$cards  %>%  \n    filter(!is.na(rating), rarity %in% c(\"Common\")) \n  \n  ### check whether a fixed card has to be includes\n  if(!is.null(fixcard)){\n    if(fixcard %in% c(rares$number, uncommons$number, commons$number)){\n      if(fixcard %in% rares$number){\n        n_rares <- n_rares - 1\n        rares <- rares %>% filter(number != fixcard)\n      }\n      if(fixcard %in% uncommons$number){\n        n_uncommons <- n_uncommons - 1\n        uncommons <- uncommons %>% filter(number != fixcard)\n      }\n      if(fixcard %in% commons$number){\n        n_commons <- n_commons - 1\n        commons <- commons %>% filter(number != fixcard)\n      }\n      fix_sample <- rep(fixcard, n_booster)\n    } else {\n      warning(\"Fixed card not contained in set\")\n      fix_sample <- character(0)\n    }\n  } else {\n    fix_sample <- character(0)\n  }\n  \n  ### sample rares, uncommons, commons for each booster\n  r_sample <- sapply(seq(n_booster), function(i){\n    sample(rares$number, size = n_rares, replace = FALSE, prob = rares$prob)\n  }) %>% unlist\n  u_sample <- sapply(seq(n_booster), function(i){\n    sample(uncommons$number, size = n_uncommons, replace = FALSE)\n  }) %>% unlist\n  c_sample <- sapply(seq(n_booster), function(i){\n    sample(commons$number, size = n_commons, replace = FALSE)\n  }) %>% unlist\n  \n  ### combine all samples into booster matrix\n  matrix(rbind(fix_sample, r_sample, u_sample, c_sample), \n         nrow = length(fixcard) + n_rares + n_uncommons + n_commons)\n}\n\n### translate card ratings into pick probabilities\n### model is based on generalized ELO-model for multiple options, i.e.\n### the rating scale corresponds to the log-Odds scale\n### (ratings differences among mulitple cards are consistend with corresponding Odds-Ratios)\n### The remaining optimization problem is to find a PROPER probability vector which\n### satisfies the predetermined OddsRatios\n### Elo-coeff to translate ratings into logOdds was inferred from draftaholics.com\n### (by trial and error)\n\nratings2probs <- function(ratings, coeff = 200){\n  if(length(ratings) == 0){return(1)}\n  ### compute rating difference with respect to maximum rating\n  rating_diffs <- ratings - max(ratings)\n  ### function to compute probs according to max probability based on log-odds relation\n  probs_from_max <- function(maxprob){\n    alpha <- maxprob / (1 - maxprob) * exp(2 * rating_diffs / coeff)\n    probs <- alpha / (1 + alpha)\n    probs\n  }\n  ### compute max probability subject to probabilities sum of one (proper distribution)\n  max_prob <- uniroot(f = function(p){sum(probs_from_max(p)) - 1}, interval = c(0.0001,0.9999))\n  ### return prob vector subject to proper max probability\n  probs <- probs_from_max(max_prob$root)\n  probs / sum(probs)\n}\n\n### function to compute first pick distirbution given setdata with ratings attached\n\ncompute_firstpicks <- function(rated_setdata, samplesize = 100000){\n  ### cut down card rating vector\n  elig_cards <- rated_setdata$cards %>%  \n    filter(!is.na(rating)) %>% \n    .[[\"number\"]]\n  card_ratings <- rated_setdata$cards %>%  \n    filter(!is.na(rating)) %>% \n    .[[\"rating\"]]       \n  names(card_ratings) <- elig_cards\n  empty_probs <- setNames(rep(0, length(elig_cards)), elig_cards)\n  \n  ### generate boosters and make picks\n  boosters <- sample_booster(rated_setdata, n = samplesize)\n  card_pickprobs <- sapply(seq(dim(boosters)[2]), FUN = function(b_nr){\n    booster_cards <- boosters[, b_nr]\n    booster_probs <- empty_probs\n    booster_probs[booster_cards] <- ratings2probs(card_ratings[booster_cards])\n    booster_probs\n  })\n  \n  ### summarize the results\n  pickprobs_df <- data.frame(number = rownames(card_pickprobs),\n                             p1p1 = rowSums(card_pickprobs) / samplesize,\n                             stringsAsFactors = F,\n                             row.names = NULL)\n  \n  mod_data <- rated_setdata\n  mod_data$cards <- left_join(mod_data$cards, pickprobs_df, by = \"number\")\n  mod_data\n}\n\n\n### function to compute pick point distirbution of specific card based on\n### given setdata with ratings attached\n\ncompute_pp_dist <- function(rated_setdata, fixcard, samplesize = 1000){\n  ### cut down card rating vector\n  elig_cards <- rated_setdata$cards %>%  \n    filter(!is.na(rating)) %>% \n    .[[\"number\"]]\n  card_ratings <- rated_setdata$cards %>%  \n    filter(!is.na(rating)) %>% \n    .[[\"rating\"]]       \n  names(card_ratings) <- elig_cards\n\n  ### generate boosters\n  boosters <- sample_booster(rated_setdata, n = samplesize, fixcard = fixcard)\n  \n  ### compute pick point distribution per booster\n  ppd_bybooster <- sapply(seq(dim(boosters)[2]), FUN = function(b_nr){\n    ppd <- numeric(0)\n    booster_cards <- boosters[, b_nr] \n    repeat{\n      ## compute card pick probabilities\n      cp_probs <- ratings2probs(card_ratings[booster_cards])\n      ## compute probability of fixcard being still in pack times being picked next\n      ppd <- c(ppd, (1 - sum(ppd)) * cp_probs[fixcard])\n      ## randomly pcik non-fixcard subject to pick_probs\n      res_cards <- setdiff(names(cp_probs), fixcard)\n      pick <- sample(res_cards, size = 1, replace = FALSE, prob = cp_probs[res_cards])\n      booster_cards <- setdiff(booster_cards, pick)\n      if(length(booster_cards) == 1) break\n    }\n    ## return complete pick point distribution\n    setNames(c(ppd, 1 - sum(ppd)), NULL)\n  })\n    \n  ### summarize the results\n  rowSums(ppd_bybooster) / samplesize\n}",
    "created" : 1517604013150.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1468264147",
    "id" : "20BCF2FD",
    "lastKnownWriteTime" : 1520026379,
    "path" : "C:/Users/Felix/Desktop/mtganalyze/signaldetection/helpers.R",
    "project_path" : "helpers.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_source"
}